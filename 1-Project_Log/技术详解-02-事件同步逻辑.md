# äº‹ä»¶åŒæ­¥é€»è¾‘è¯¦è§£

## æ¦‚è¿°

è¿™ä¸€éƒ¨åˆ†è¯¦ç»†è§£é‡Šå¦‚ä½•å°† ScheduleMaster çš„äº‹ä»¶åŒæ­¥åˆ° Google Calendarã€‚

### æ ¸å¿ƒæµç¨‹

```
ç”¨æˆ·ç‚¹å‡»"åŒæ­¥" â†’ è·å–æœ¬åœ°äº‹ä»¶ â†’ è¿‡æ»¤éœ€è¦åŒæ­¥çš„äº‹ä»¶ â†’
æ˜ å°„åˆ° Google æ ¼å¼ â†’ è°ƒç”¨ Google API â†’ å­˜å‚¨æ˜ å°„å…³ç³» â†’ æ˜¾ç¤ºç»“æœ
```

---

## ğŸ“Š æ•°æ®æ˜ å°„

### ScheduleMaster äº‹ä»¶ â†’ Google Calendar äº‹ä»¶

#### äº‹ä»¶ç»“æ„å¯¹æ¯”

**ScheduleMaster Event** (`lib/types.ts`):
```typescript
interface Event {
  id: string
  title: string
  description?: string
  startTime: string        // "14:30"
  endTime: string          // "15:30"
  selectedDays: number[]   // [1, 2, 3] - å‘¨ä¸€ã€å‘¨äºŒã€å‘¨ä¸‰
  color: string            // "blue", "green", "red", etc.
  category?: string
  location?: string
  startDate?: string       // "2025-12-31"
  endDate?: string         // "2025-12-31"
}
```

**Google Calendar Event**:
```typescript
{
  id: string               // Google ç”Ÿæˆçš„äº‹ä»¶ ID
  summary: string          // å¯¹åº” title
  description: string      // å¯¹åº” description
  start: {
    dateTime: string       // "2025-12-31T14:30:00+08:00"
    // æˆ–
    date: string           // "2025-12-31" (å…¨å¤©äº‹ä»¶)
  }
  end: {
    dateTime: string
    // æˆ–
    date: string
  }
  colorId: string          // "1" - "11" (Google é¢œè‰² ID)
  location: string
  recurrence: string[]     // å¾ªç¯äº‹ä»¶çš„è§„åˆ™ (RRULE)
}
```

---

### æ˜ å°„è§„åˆ™

#### 1. åŸºç¡€å­—æ®µæ˜ å°„

```typescript
// lib/event-mapper.ts
import { type Event } from './types'

export function mapToGoogleEvent(
  localEvent: Event,
  weekStart: Date
): GoogleCalendarEvent {
  // è®¡ç®—äº‹ä»¶çš„å¼€å§‹å’Œç»“æŸæ—¥æœŸæ—¶é—´
  const { startDateTime, endDateTime } = calculateEventDateTime(
    localEvent,
    weekStart
  )

  // é¢œè‰²æ˜ å°„
  const colorId = mapColorToGoogle(localEvent.color)

  // æ„å»º Google äº‹ä»¶å¯¹è±¡
  const googleEvent: GoogleCalendarEvent = {
    summary: localEvent.title,
    description: localEvent.description || '',
    start: {
      dateTime: startDateTime.toISOString(),
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    },
    end: {
      dateTime: endDateTime.toISOString(),
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    },
    location: localEvent.location || '',
    colorId: colorId,
  }

  // å¤„ç†å¤šå¤©äº‹ä»¶
  if (localEvent.selectedDays.length > 1) {
    googleEvent.recurrence = generateRecurrenceRule(
      localEvent.selectedDays,
      weekStart,
      localEvent.endDate
    )
  }

  return googleEvent
}
```

#### 2. é¢œè‰²æ˜ å°„

```typescript
// lib/color-mapper.ts

const COLOR_MAP: Record<string, string> = {
  // Google Calendar Color IDs:
  // 1: è“è‰² (Blue)
  // 2: ç»¿è‰² (Green)
  // 3: ç´«è‰² (Purple)
  // 4: çº¢è‰² (Red)
  // 5: é»„è‰² (Yellow)
  // 6: æ©™è‰² (Orange)
  // 7: é’è‰² (Turquoise)
  // 8: ç°è‰² (Gray)
  // 9: è“ç»¿è‰² (Bold Blue)
  // 10: é’ç»¿è‰² (Bold Green)
  // 11: çº¢è‰² (Bold Red)

  blue: '1',
  green: '2',
  purple: '3',
  red: '4',
  yellow: '5',
  orange: '6',
  turquoise: '7',
  gray: '8',
}

export function mapColorToGoogle(color: string): string {
  return COLOR_MAP[color] || '1'  // é»˜è®¤è“è‰²
}

export function mapColorFromGoogle(colorId: string): string {
  const reverseMap: Record<string, string> = {}
  Object.entries(COLOR_MAP).forEach(([key, value]) => {
    reverseMap[value] = key
  })
  return reverseMap[colorId] || 'blue'
}
```

#### 3. æ—¥æœŸæ—¶é—´è®¡ç®—

```typescript
// lib/datetime-utils.ts

export function calculateEventDateTime(
  event: Event,
  weekStart: Date
): { startDateTime: Date; endDateTime: Date } {
  // ScheduleMaster çš„ selectedDays æ˜¯ç›¸å¯¹äºå‘¨å¼€å§‹çš„å¤©æ•°åç§»
  // 0 =å‘¨æ—¥, 1 =å‘¨ä¸€, 2 =å‘¨äºŒ, ..., 6 =å‘¨å…­

  // è·å–ç¬¬ä¸€ä¸ªé€‰ä¸­çš„æ—¥æœŸ
  const firstDayOffset = event.selectedDays[0]
  const eventDate = addDays(weekStart, firstDayOffset)

  // è§£æå¼€å§‹å’Œç»“æŸæ—¶é—´
  const [startHour, startMinute] = event.startTime.split(':').map(Number)
  const [endHour, endMinute] = event.endTime.split(':').map(Number)

  // æ„å»ºå®Œæ•´çš„æ—¥æœŸæ—¶é—´
  const startDateTime = new Date(eventDate)
  startDateTime.setHours(startHour, startMinute, 0, 0)

  const endDateTime = new Date(eventDate)
  endDateTime.setHours(endHour, endMinute, 0, 0)

  // å¤„ç†è·¨æ—¥æƒ…å†µï¼ˆç»“æŸæ—¶é—´æ—©äºå¼€å§‹æ—¶é—´ï¼‰
  if (endDateTime < startDateTime) {
    endDateTime.setDate(endDateTime.getDate() + 1)
  }

  return { startDateTime, endDateTime }
}

function addDays(date: Date, days: number): Date {
  const result = new Date(date)
  result.setDate(result.getDate() + days)
  return result
}
```

#### 4. å¤šå¤©äº‹ä»¶å¤„ç†ï¼ˆå¾ªç¯äº‹ä»¶ï¼‰

```typescript
// lib/recurrence-utils.ts

export function generateRecurrenceRule(
  selectedDays: number[],
  weekStart: Date,
  endDate?: string
): string[] {
  // Google Calendar RRULE æ ¼å¼
  // RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR;UNTIL=20251231T235959Z

  // è½¬æ¢ selectedDays (0-6) åˆ° Google çš„ BYDAY æ ¼å¼ (SU, MO, TU, WE, TH, FR, SA)
  const dayMap: Record<number, string> = {
    0: 'SU',
    1: 'MO',
    2: 'TU',
    3: 'WE',
    4: 'TH',
    5: 'FR',
    6: 'SA',
  }

  const byDay = selectedDays.map(day => dayMap[day]).sort().join(',')

  const rrule = `RRULE:FREQ=WEEKLY;BYDAY=${byDay}`

  // å¦‚æœæœ‰ç»“æŸæ—¥æœŸï¼Œæ·»åŠ  UNTIL
  if (endDate) {
    const untilDate = new Date(endDate)
    const until = untilDate.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    return [`${rrule};UNTIL=${until}`]
  }

  return [rrule]
}
```

---

## ğŸ”„ åŒæ­¥æµç¨‹è¯¦è§£

### å®Œæ•´åŒæ­¥ API

**æ–‡ä»¶**: `app/api/calendar/sync/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import { google } from 'googleapis'
import { createClient } from '@supabase/supabase-js'
import { getAuthenticatedClient } from '@/lib/google-calendar'
import { mapToGoogleEvent } from '@/lib/event-mapper'
import { EVENTS_STORAGE_KEY } from '@/lib/storage-keys'

interface SyncResult {
  success: boolean
  message: string
  synced: number
  failed: number
  errors: Array<{ eventId: string; error: string }>
}

export async function POST(req: NextRequest) {
  // 1. éªŒè¯ç”¨æˆ·èº«ä»½å’Œæƒé™
  const { userId } = await auth()
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // 2. è·å–è¯·æ±‚å‚æ•°
  const body = await req.json()
  const mode = body.mode || 'incremental'  // 'full' æˆ– 'incremental'

  try {
    // 3. è·å– Google Calendar è®¤è¯å®¢æˆ·ç«¯
    const oauth2Client = await getAuthenticatedClient(userId)
    const calendar = google.calendar({ version: 'v3', auth: oauth2Client })

    // 4. è·å–ç”¨æˆ·çš„æ—¥å† ID
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )

    const { data: account } = await supabase
      .from('google_accounts')
      .select('calendar_id')
      .eq('user_id', userId)
      .single()

    const calendarId = account?.calendar_id || 'primary'

    // 5. è·å–æœ¬åœ°äº‹ä»¶
    // æ³¨æ„ï¼šè¿™é‡Œå‡è®¾äº‹ä»¶å­˜å‚¨åœ¨ Supabase çš„ events è¡¨
    // å¦‚æœä½¿ç”¨ localStorageï¼Œéœ€è¦ä»å‰ç«¯ä¼ é€’
    const { data: localEvents, error: eventsError } = await supabase
      .from('events')
      .select('*')
      .eq('user_id', userId)

    if (eventsError) throw eventsError

    // 6. è¿‡æ»¤éœ€è¦åŒæ­¥çš„äº‹ä»¶
    let eventsToSync = localEvents

    if (mode === 'incremental') {
      // å¢é‡åŒæ­¥ï¼šåªåŒæ­¥æ–°å¢æˆ–ä¿®æ”¹çš„äº‹ä»¶
      const { data: mappings } = await supabase
        .from('google_event_mappings')
        .select('local_event_id')
        .eq('user_id', userId)

      const syncedEventIds = new Set(mappings?.map(m => m.local_event_id) || [])

      // è¿‡æ»¤å‡ºæœªåŒæ­¥çš„äº‹ä»¶
      eventsToSync = localEvents.filter(event => !syncedEventIds.has(event.id))
    }

    // 7. åŒæ­¥äº‹ä»¶
    const result: SyncResult = {
      success: true,
      message: '',
      synced: 0,
      failed: 0,
      errors: [],
    }

    const weekStart = new Date()  // æˆ–ä»è¯·æ±‚å‚æ•°è·å–

    for (const event of eventsToSync) {
      try {
        // æ˜ å°„åˆ° Google æ ¼å¼
        const googleEvent = mapToGoogleEvent(event, weekStart)

        // è°ƒç”¨ Google Calendar API
        const { data: createdEvent } = await calendar.events.insert({
          calendarId: calendarId,
          requestBody: googleEvent,
        })

        // å­˜å‚¨æ˜ å°„å…³ç³»
        if (createdEvent.id) {
          await supabase
            .from('google_event_mappings')
            .insert({
              local_event_id: event.id,
              google_event_id: createdEvent.id,
              user_id: userId,
              synced_at: new Date().toISOString(),
            })

          result.synced++
        }

      } catch (error: any) {
        result.failed++
        result.errors.push({
          eventId: event.id,
          error: error.message || 'Unknown error',
        })
      }
    }

    // 8. ç”Ÿæˆç»“æœæ¶ˆæ¯
    if (result.failed === 0) {
      result.message = `æˆåŠŸåŒæ­¥ ${result.synced} ä¸ªäº‹ä»¶åˆ° Google Calendar`
    } else {
      result.message = `åŒæ­¥å®Œæˆï¼š${result.synced} ä¸ªæˆåŠŸï¼Œ${result.failed} ä¸ªå¤±è´¥`
    }

    return NextResponse.json(result)

  } catch (error: any) {
    console.error('Sync error:', error)
    return NextResponse.json(
      {
        success: false,
        message: error.message || 'åŒæ­¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
        synced: 0,
        failed: 0,
      },
      { status: 500 }
    )
  }
}
```

---

## ğŸ“¦ åŒæ­¥ä¼˜åŒ–

### æ‰¹é‡æ“ä½œ

Google Calendar API æ”¯æŒæ‰¹é‡æ“ä½œï¼Œå¯ä»¥å‡å°‘è¯·æ±‚æ¬¡æ•°ï¼š

```typescript
// ä½¿ç”¨æ‰¹é‡æ“ä½œ
const batch = google.calendar({ version: 'v3', auth: oauth2Client }).newBatch()

eventsToSync.forEach((event, index) => {
  const googleEvent = mapToGoogleEvent(event, weekStart)
  const request = calendar.events.insert({
    calendarId: 'primary',
    requestBody: googleEvent,
  })
  batch.add(request, { id: event.id })
})

// æ‰§è¡Œæ‰¹é‡è¯·æ±‚
const responses = await batch.exec()

// å¤„ç†å“åº”
Object.entries(responses).forEach(([eventId, response]) => {
  if (response.status === 200) {
    // å­˜å‚¨æ˜ å°„å…³ç³»
    await supabase
      .from('google_event_mappings')
      .insert({
        local_event_id: eventId,
        google_event_id: response.data.id,
        user_id: userId,
        synced_at: new Date().toISOString(),
      })
  }
})
```

---

### é”™è¯¯å¤„ç†å’Œé‡è¯•

```typescript
// lib/sync-utils.ts

export async function syncWithRetry(
  calendar: any,
  googleEvent: any,
  maxRetries = 3
): Promise<{ success: boolean; eventId?: string; error?: string }> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const { data } = await calendar.events.insert({
        calendarId: 'primary',
        requestBody: googleEvent,
      })

      return { success: true, eventId: data.id }

    } catch (error: any) {
      const isRetryable = (
        error.code === 429 ||  // Rate limit
        error.code === 500 ||  // Server error
        error.code === 503     // Service unavailable
      )

      if (isRetryable && attempt < maxRetries) {
        // ç­‰å¾…åé‡è¯•ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
        const delay = Math.pow(2, attempt) * 1000  // 1s, 2s, 4s
        await new Promise(resolve => setTimeout(resolve, delay))
        continue
      }

      return {
        success: false,
        error: error.message || 'Unknown error',
      }
    }
  }

  return { success: false, error: 'Max retries exceeded' }
}
```

---

## ğŸ¯ ç‰¹æ®Šåœºæ™¯å¤„ç†

### åœºæ™¯ 1: å¤šå¤©äº‹ä»¶

ScheduleMaster æ”¯æŒåœ¨å¤šå¤©åˆ›å»ºäº‹ä»¶ï¼ˆä¾‹å¦‚ï¼šå‘¨ä¸€ã€å‘¨ä¸‰ã€å‘¨äº”çš„ä¼šè®®ï¼‰ã€‚

**é—®é¢˜**: Google Calendar ä¸­åº”è¯¥å¦‚ä½•è¡¨ç¤ºï¼Ÿ

**æ–¹æ¡ˆ 1: ä½¿ç”¨å¾ªç¯äº‹ä»¶ï¼ˆæ¨èï¼‰**
```typescript
// ä¼˜ç‚¹ï¼šä¸€ä¸ªäº‹ä»¶è¡¨ç¤ºæ‰€æœ‰é‡å¤
// ç¼ºç‚¹ï¼šéœ€è¦ç†è§£ RRULE æ ¼å¼

const googleEvent = {
  summary: 'Weekly Meeting',
  start: { dateTime: '2025-12-31T14:00:00+08:00' },
  end: { dateTime: '2025-12-31T15:00:00+08:00' },
  recurrence: ['RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR'],
}
```

**æ–¹æ¡ˆ 2: åˆ›å»ºå¤šä¸ªç‹¬ç«‹äº‹ä»¶**
```typescript
// ä¼˜ç‚¹ï¼šç®€å•ç›´è§‚ï¼Œæ˜“äºç†è§£
// ç¼ºç‚¹ï¼šä¿®æ”¹æ—¶éœ€è¦æ›´æ–°å¤šä¸ªäº‹ä»¶

const events = []
for (const dayOffset of [1, 3, 5]) {  // å‘¨ä¸€ã€å‘¨ä¸‰ã€å‘¨äº”
  const eventDate = addDays(weekStart, dayOffset)
  const googleEvent = mapToGoogleEvent(localEvent, eventDate)
  events.push(googleEvent)
}

// æ‰¹é‡åˆ›å»º
for (const event of events) {
  await calendar.events.insert({
    calendarId: 'primary',
    requestBody: event,
  })
}
```

**æ¨è**: ä½¿ç”¨æ–¹æ¡ˆ 1ï¼ˆå¾ªç¯äº‹ä»¶ï¼‰ï¼Œæ›´ç¬¦åˆ Google Calendar çš„è®¾è®¡ç†å¿µã€‚

---

### åœºæ™¯ 2: å…¨å¤©äº‹ä»¶

å¦‚æœäº‹ä»¶æ²¡æœ‰æŒ‡å®šæ—¶é—´ï¼Œåº”è¯¥åˆ›å»ºä¸ºå…¨å¤©äº‹ä»¶ï¼š

```typescript
export function mapToGoogleEvent(
  localEvent: Event,
  weekStart: Date
): GoogleCalendarEvent {
  const isAllDay = !localEvent.startTime && !localEvent.endTime

  if (isAllDay) {
    // å…¨å¤©äº‹ä»¶
    const eventDate = addDays(weekStart, localEvent.selectedDays[0])
    const dateStr = eventDate.toISOString().split('T')[0]

    return {
      summary: localEvent.title,
      description: localEvent.description || '',
      start: { date: dateStr },      // æ³¨æ„ï¼šä½¿ç”¨ date è€Œä¸æ˜¯ dateTime
      end: { date: dateStr },
    }
  } else {
    // æœ‰æ—¶é—´çš„äº‹ä»¶
    // ... æ­£å¸¸å¤„ç†
  }
}
```

---

### åœºæ™¯ 3: æ—¶åŒºå¤„ç†

**é—®é¢˜**: ç”¨æˆ·åœ¨ä¸åŒæ—¶åŒºï¼Œå¦‚ä½•ç¡®ä¿äº‹ä»¶æ—¶é—´æ­£ç¡®ï¼Ÿ

**æ–¹æ¡ˆ**: ä½¿ç”¨ç”¨æˆ·æœ¬åœ°æ—¶åŒº

```typescript
// è·å–ç”¨æˆ·æ—¶åŒº
const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone
// ä¾‹å¦‚: "Asia/Shanghai", "America/New_York"

// åœ¨äº‹ä»¶ä¸­æŒ‡å®šæ—¶åŒº
const googleEvent = {
  summary: localEvent.title,
  start: {
    dateTime: startDateTime.toISOString(),
    timeZone: timeZone,  // â† æ·»åŠ æ—¶åŒº
  },
  end: {
    dateTime: endDateTime.toISOString(),
    timeZone: timeZone,
  },
}
```

**æœ€ä½³å®è·µ**:
1. åœ¨æ•°æ®åº“ä¸­å­˜å‚¨ç”¨æˆ·çš„æ—¶åŒºè®¾ç½®
2. åŒæ­¥æ—¶ä½¿ç”¨ç”¨æˆ·çš„æ—¶åŒº
3. æ˜¾ç¤ºæ—¶æ ¹æ®ç”¨æˆ·è®¾ç½®è½¬æ¢æ—¶é—´

---

### åœºæ™¯ 4: å†²çªæ£€æµ‹

Google Calendar å…è®¸äº‹ä»¶é‡å ï¼Œä½†å¯ä»¥æ£€æµ‹å†²çªï¼š

```typescript
// æ£€æŸ¥äº‹ä»¶æ˜¯å¦å†²çª
async function checkConflict(
  calendar: any,
  googleEvent: any
): Promise<boolean> {
  const timeMin = googleEvent.start.dateTime
  const timeMax = googleEvent.end.dateTime

  const { data: events } = await calendar.events.list({
    calendarId: 'primary',
    timeMin: timeMin,
    timeMax: timeMax,
    singleEvents: true,
  })

  return events.items && events.items.length > 0
}

// ä½¿ç”¨
const hasConflict = await checkConflict(calendar, googleEvent)

if (hasConflict) {
  // æç¤ºç”¨æˆ·æœ‰å†²çª
  return {
    success: false,
    error: 'è¯¥æ—¶é—´æ®µå·²æœ‰å…¶ä»–äº‹ä»¶',
  }
}
```

---

## ğŸ§ª æµ‹è¯•åŒæ­¥é€»è¾‘

### å•å…ƒæµ‹è¯•

```typescript
// __tests__/event-mapper.test.ts

import { mapToGoogleEvent } from '@/lib/event-mapper'

describe('Event Mapper', () => {
  it('should map single day event correctly', () => {
    const localEvent = {
      id: '1',
      title: 'Test Event',
      startTime: '14:00',
      endTime: '15:00',
      selectedDays: [1],  // å‘¨ä¸€
      color: 'blue',
    }

    const weekStart = new Date('2025-12-29T00:00:00Z')  // å‘¨æ—¥
    const googleEvent = mapToGoogleEvent(localEvent, weekStart)

    expect(googleEvent.summary).toBe('Test Event')
    expect(googleEvent.start.dateTime).toContain('2025-12-30T14:00:00')
    expect(googleEvent.colorId).toBe('1')
  })

  it('should map multi-day event with recurrence', () => {
    const localEvent = {
      id: '2',
      title: 'Weekly Meeting',
      startTime: '10:00',
      endTime: '11:00',
      selectedDays: [1, 3, 5],  // å‘¨ä¸€ã€å‘¨ä¸‰ã€å‘¨äº”
      color: 'red',
    }

    const weekStart = new Date('2025-12-29T00:00:00Z')
    const googleEvent = mapToGoogleEvent(localEvent, weekStart)

    expect(googleEvent.recurrence).toContain('BYDAY=MO,WE,FR')
  })
})
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. åˆ†é¡µå¤„ç†

å¦‚æœäº‹ä»¶å¾ˆå¤šï¼Œåº”è¯¥åˆ†æ‰¹åŒæ­¥ï¼š

```typescript
const BATCH_SIZE = 50

for (let i = 0; i < eventsToSync.length; i += BATCH_SIZE) {
  const batch = eventsToSync.slice(i, i + BATCH_SIZE)

  // åŒæ­¥è¿™ä¸€æ‰¹
  for (const event of batch) {
    await syncEvent(calendar, event)
  }

  // æ›´æ–°è¿›åº¦
  const progress = Math.min((i + BATCH_SIZE) / eventsToSync.length * 100, 100)
  // å‘é€è¿›åº¦æ›´æ–°åˆ°å®¢æˆ·ç«¯ï¼ˆä½¿ç”¨ SSE æˆ– WebSocketï¼‰
}
```

### 2. å¹¶å‘æ§åˆ¶

åŒæ—¶åŒæ­¥å¤šä¸ªäº‹ä»¶ï¼ˆä½†è¦æ§åˆ¶å¹¶å‘æ•°ï¼Œé¿å…è§¦å‘é€Ÿç‡é™åˆ¶ï¼‰ï¼š

```typescript
import pLimit from 'p-limit'

const limit = pLimit(5)  // æœ€å¤š 5 ä¸ªå¹¶å‘è¯·æ±‚

const tasks = eventsToSync.map(event =>
  limit(() => syncEvent(calendar, event))
)

await Promise.all(tasks)
```

---

## ğŸ¯ æ€»ç»“

### äº‹ä»¶åŒæ­¥çš„å…³é”®ç‚¹

1. **æ•°æ®æ˜ å°„**:
   - è½¬æ¢ ScheduleMaster æ ¼å¼åˆ° Google Calendar æ ¼å¼
   - å¤„ç†é¢œè‰²ã€æ—¶é—´ã€å¤šå¤©äº‹ä»¶çš„æ˜ å°„

2. **åŒæ­¥ç­–ç•¥**:
   - å¢é‡åŒæ­¥ï¼šåªåŒæ­¥æ–°äº‹ä»¶
   - å…¨é‡åŒæ­¥ï¼šé‡æ–°åŒæ­¥æ‰€æœ‰äº‹ä»¶
   - å­˜å‚¨æ˜ å°„å…³ç³»ï¼Œé¿å…é‡å¤åŒæ­¥

3. **é”™è¯¯å¤„ç†**:
   - ç½‘ç»œé”™è¯¯è‡ªåŠ¨é‡è¯•
   - è¯¦ç»†çš„é”™è¯¯æ—¥å¿—
   - å‹å¥½çš„ç”¨æˆ·æç¤º

4. **æ€§èƒ½ä¼˜åŒ–**:
   - æ‰¹é‡æ“ä½œå‡å°‘è¯·æ±‚æ¬¡æ•°
   - åˆ†é¡µå¤„ç†å¤§é‡äº‹ä»¶
   - å¹¶å‘æ§åˆ¶æé«˜æ•ˆç‡

---

**ä¸‹ä¸€æ­¥**: æŸ¥çœ‹ [æŠ€æœ¯è¯¦è§£-03-å‰ç«¯UIå®ç°.md](./æŠ€æœ¯è¯¦è§£-03-å‰ç«¯UIå®ç°.md)
