# AI 编程

## 一、 从“打字员”转变为“指挥官”

在传统编程中，你大部分时间在思考“怎么写（How）”；而在 AI 辅助时代，你的核心价值在于思考<font color=red>**“写什么（What）”**和**“为什么这么写（Why）”**</font>。

### 1. 上下文即生产力 (Context is King)

AI 的表现上限直接取决于你提供的上下文质量。

- **全局感知：** 使用支持“全库扫描”的工具（如 **Cursor (Composer)**, **Windsurf**, 或 **GitHub Copilot Workspace**）。
- **精准喂养：** 如果 AI 找不到某个函数，手动将相关文件 `@` 进对话，或者**把 API 文档的 URL 直接贴给它**。

### 2. 任务拆解 (Divide & Conquer)

<font color=red>**不要试图让 AI 一次性生成一个庞大的复杂系统。AI 在处理 200 行以内的逻辑时准确率最高**。</font>

- **原子化需求： 每次只下达一个明确的指令（如：“添加一个邮箱验证逻辑”，而不是“完成用户注册系统”）。**
- **伪代码导航： 在要求 AI 写复杂逻辑前，先让它出一份技术实现方案（Spec）。**

------

## 二、 指令编写（Prompting）的最佳实践

为了获得高质量代码，一个标准的指令应包含以下四个要素：

| **要素**                   | **说明**                   | **示例**                                                     |
| -------------------------- | -------------------------- | ------------------------------------------------------------ |
| **角色 (Persona)**         | 定义 AI 的专业身份         | “你是一位精通 Next.js 和性能优化的资深架构师。”              |
| **上下文 (Context)**       | 提供当前环境和依赖信息     | “当前项目使用 Tailwind CSS，且已有 `lucide-react` 图标库。”  |
| **具体任务 (Task)**        | 使用动词开头的具体动作     | “重构 `UserList` 组件，将状态管理从 `useState` 迁移到 `Zustand`。” |
| **约束限制 (Constraints)** | 规定编码风格、性能或安全性 | “禁止使用第三方 UI 库，必须遵循项目的单向数据流原则。”       |

------

## 三、 典型的 AI 编程工作流 (Workflow)

2025 年最高效的开发者通常遵循 **“Plan-Prompt-Review-Test”** 循环：

1. 规划（Plan）：

   先与 AI 讨论架构。问它：“我要实现功能 X，在现有文件结构下，最佳的实现路径是什么？”

2. 生成（Prompt）：

   根据 AI 给出的路径，分步执行。优先生成数据模型，再生成业务逻辑（Hooks/Utils），最后是 UI 界面。

3. 审查（Review）：

   不要直接信任 AI。 重点检查其逻辑漏洞（如：是否有内存泄漏？是否处理了所有 $O(n)$ 复杂度以上的循环？）。

4. 自动化验证（Test）：

   让 AI 针对生成的代码编写单元测试。

   > **提示：** 尝试要求 AI：“请列出这段代码可能存在的 3 个边界 case，并为其编写 Jest 测试。”

------

## 四、 避坑指南：如何应对 AI 的“幻觉”

- **拒绝“Monolithic”对话：** 如果一个对话轮次过多，AI 的记忆会产生偏移。当一个子任务完成后，开启一个新的对话，并带入必要的旧上下文。
- **版本控制是救命稻草：** 在让 AI 进行大规模重构前，务必先 `git commit`。AI 有时会像“装修拆墙”一样，改坏你原本正常的逻辑。
- **手动纠偏：** 当 AI 连续三次都改不对一个 Bug 时，通常是因为你的上下文有误或模型陷入了死循环。这时请停止对话，手动修复关键点，再让 AI 继续。

------

## 五、 2025 推荐工具链

- **IDE（首选）：** **Cursor** 或 **Windsurf**（具备强大的 Agentic 能力，能自动读写文件、运行终端命令）。
- **Web 端/快速原型：** **Bolt.new** 或 **Replit Agent**（适合从零开始的一键生成）。
- **辅助工具：** **v0.dev**（专门用于生成 React/Next.js 的 UI 组件氛围）。

# Vibe Coding

**Vibe Coding（氛围编程）** 这个词最近在开发者社区（尤其是由 Andrej Karpathy 等技术大牛推广后）火速出圈。

简单来说，**Vibe Coding 是一种“只管提要求，不管写代码”的开发范式。** 程序员不再是“打字员”，而变成了“产品制作人”或“导演”。你提供的是一种“感觉（Vibe）”、一个愿景或是一系列高层逻辑，而具体的语法实现、Debug、环境配置甚至部署，全部交给具备 **Agentic（代理）能力**的 AI。

对于像你这样有计算机背景的**独立开发者**来说，Vibe Coding 是实现“一人公司”或“极速原型开发”的最强武器。

------

## 一、 什么是 Vibe Coding 的核心？

在传统的 AI 辅助编程中，你还需要看代码、改代码。但在 Vibe Coding 中，工作流发生了质变：

- **从“行”到“流”：** 你不再一行行审阅代码，而是审阅 AI 提交的一系列**文件变更（Diffs）**。
- **Agentic Workflow：** 以前 AI 只能在对话框里写代码；现在的 AI 工具（如 Cursor Composer 或 Claude Code）可以**自动打开终端、运行命令、读取报错、修改文件、甚至去浏览器查看运行效果**。
- **关注“意图”而非“语法”：** 你对 AI 说：“这里感觉不对，侧边栏应该更现代一点，加个磨砂玻璃效果，并把刚才那个报错修复了。”AI 随即完成一系列复杂的底层操作。

------

## 二、 Vibe Coding 的最佳实践方式

要玩转 Vibe Coding，关键在于如何高效地“指挥”这些具备代理能力的 AI 工具。

### 1. 选择“手脚并用”的工具链

Vibe Coding 依赖于 AI 对你本地系统的控制权。

- **Cursor (Composer Mode):** 目前最成熟的 Vibe Coding 工具。按下 `Cmd+I`，进入全库编辑模式。
- **Claude Code:** Anthropic 推出的命令行工具，它可以直接在你的终端里运行，自己执行 `npm install` 或 `git commit`。
- **Windsurf:** 强调“流（Flow）”概念的 IDE，上下文感应非常灵敏。
- **Bolt.new / Lovable:** 适合从零开始构建全栈 Web 应用，连环境都不用配，直接在浏览器里“Vibe”。

### 2. “大处着眼，小处迭代” (The Loop)

- **初始化：** 描述你的愿景。“帮我做一个像 Notion 一样的笔记应用，用 Next.js + Tailwind + Supabase。”
- **持续反馈：** 看到生成的页面后，直接给建议。“左边的间距太大了”、“点击按钮时加一个微交互动画”、“这个功能逻辑反了”。
- **不要轻易看源码：** 在 Vibe 的过程中，优先关注**运行结果**。只有当 AI 反复修不好某个 Bug 时，你才作为“资深工程师”下场进行代码层面的精准打击。

### 3. 构建“参考资料库” (The Knowledge)

AI 需要知道你的“口味”。

- **引用文档：** 在 Cursor 中使用 `@Doc` 引用最新的 Next.js 或 Clerk 文档，防止 AI 使用过时的 API。
- **提供示例：** 给 AI 截张图或提供一段你喜欢的 UI 代码，告诉它：“按照这个 Vibe 来写”。

### 4. 保持 Git 提交的“微节奏”

因为 AI 修改文件的速度极快（一次可能改动 10 个文件），**频繁提交 Git** 是 Vibe Coding 的保险杠。

- 当 AI 完成了一个让你满意的功能点，立刻 `git commit`。
- 如果接下来的 Vibe 搞砸了，直接回滚，不要试图让 AI 去修复它自己造成的混乱。

------

## 三、 Vibe Coding 的优缺点

| **优点 (High Vibe)**                         | **挑战 (Low Vibe)**                                 |
| -------------------------------------------- | --------------------------------------------------- |
| **极致速度：** 10 分钟完成以往 2 小时的活。  | **黑盒效应：** 你可能不完全清楚代码底层是怎么跑的。 |
| **降低心智负担：** 专注产品逻辑和用户体验。  | **过度依赖：** AI 幻觉可能导致难以察觉的逻辑漏洞。  |
| **全栈能力：** 后端开发者也能写出精美的 UI。 | **技术债：** 如果不加约束，生成的代码可能结构混乱。 |

------

## 四、 给你的进阶建议

既然你已经有计算机基础，并且想通过 Gemini 创建专业的编程 Gem，你可以尝试以下操作：

1. **定义你的“专家 Gem”：** 在创建 Gem 时，给它设定一个 **“Vibe Architect”** 的角色。告诉它：“你是一个擅长简洁代码、追求极致 UX 的架构师，你的任务是指导我使用 Cursor Composer 进行开发，并在我偏离最佳实践时提醒我。”
2. **实践项目：** 尝试用 **Next.js + Cursor** 在 30 分钟内复刻一个你常用的工具。

**你想让我帮你写一段用于创建“Vibe Coding 专家”Gem 的 System Prompt（系统提示词）吗？** 这样你就可以在开发时随时调用它来优化你的指令。